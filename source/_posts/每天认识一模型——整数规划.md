---
title: 每天认识一模型--规划求解之整数规划
date: 2025-07-29 12:40:17
categories: 数模备战
cover: /img/post8.jpg
---
今天我们来学习整数规划。整数规划（Integer Programming, IP）是数学规划的一个重要分支，主要研究决策变量部分或全部限制为整数的优化问题。可以看出整数规划其实是线性规划与非线性规划的一种特殊情况，因为某个变量的取值规定为整数，而不是范围，所以在变量的处理上有所不同。

# 一、整数规划是什么
## 1、定义
整数规划是指**在一组线性或非线性约束条件下，求线性或非线性目标函数的最优值，且至少有一个决策变量必须取整数的优化问题**。
- 若所有约束和目标函数均为线性，则称为**整数线性规划**（Integer Linear Programming, ILP），这是最常见的类型；
- 若存在非线性的约束或目标函数，则称为**整数非线性规划**（Integer Nonlinear Programming, INLP），求解难度更高。
## 2、核心要素
- **决策变量**：部分或全部要求取整数（如人数、设备台数、项目数量等不可分割的量），其余可为连续变量（如时间、成本等）。
- **目标函数**：最大化或最小化某个指标（如利润、效率、成本等）。
- **约束条件**：决策变量需满足的限制（如资源上限、产能约束、逻辑关系等）。
- 
# 二、整数规划的分类
根据决策变量的整数约束范围，可分为以下三类：
## 1、纯整数规划（Pure Integer Programming）
- **特点**：所有决策变量都必须取整数（可以是正整数、负整数或零）。
- **示例**：某学校需采购若干台电脑和打印机，电脑每台 5000 元，打印机每台 2000 元，预算不超过 5 万元，求能采购的最大设备总数。此时变量 “电脑数量” 和 “打印机数量” 均为非负整数。
## 2、混合整数规划（Mixed Integer Programming, MIP）
- **特点**：部分决策变量为整数，其余为连续变量（可取任意实数）。
- **示例**：某物流公司用卡车运输货物，每辆卡车可装 10 吨货物，运输成本与行驶距离成正比。变量 “卡车数量” 需为整数，而 “运输距离”“装载量（不超过 10 吨）” 可为连续变量。
## 3、 0-1 整数规划（0-1 Integer Programming）
- **特点**：决策变量仅能取 0 或 1（是整数规划的特殊子类，也称为二进制规划）。
- **示例**：表示 “是否选择”“是否执行” 等逻辑决策（如选址问题中 “是否在某地建仓库”，变量取 1 表示选择，0 表示不选择）。

# 三、整数规划的建模关键：如何处理整数约束与逻辑关系
整数规划的建模难点在于将实际问题中的离散性和逻辑约束转化为数学表达式，以下是常见技巧：
## 1、整数变量的设定
- 对于 “数量” 类问题（如生产件数、采购数量），直接设变量为非负整数（x∈N）。
- 对于 “选择” 类问题（如是否投资项目），用 0-1 变量（x∈{0,1}），1 表示 “是”，0 表示 “否”。
## 2、逻辑约束的转化
许多实际问题包含逻辑关系（如 “互斥”“依存”“至少 / 最多选择多少”），需通过整数变量转化为数学约束：
- **互斥约束**：若方案A和方案B最多选一个，设xA,xB为0-1变量，则约束为xA+xB≤1。
- **依存约束**：若选择方案 B 必须先选择方案A，还是设xA,xB为0-1变量，则约束为xB≤xA（当xB=1时，xA必须为1）。
- **数量限制**：若从10个方案中至少选3个，则约束为∑xi≥3（xi为0-1变量）。
- **固定成本约束**：若生产某产品（x≥1）需支付固定成本C，则设0-1变量y，约束为x≤M⋅y（M为足够大的数），目标函数中加入C⋅y（当x≥1时，y=1，固定成本生效）。
  - 如何理解这个固定成本约束呢。我们来举个反例，如果没有这个约束会怎样？已知我们的模型会给我们解出最优解，那么求解器可能会选xA=10（生产10件A），但y=0（不付固定成本），此时目标函数利润更高（少付100元），但这违反了 “生产必须付固定成本” 的实际规则。

# 四、整数规划的求解算法
整数规划的可行解是离散点集，而非线性规划的连续区域，因此求解难度显著更高（属于 NP 难问题）。常用算法可分为**精确算法**和**启发式算法**：
## 1. 精确算法（适用于小规模问题）
### （1）分支定界法（Branch and Bound）
- 1、先求解整数规划的 “松弛问题”（去掉整数约束，得到线性规划），若松弛问题的最优解是整数，则直接为原问题最优解；
- 2、若不是整数，则选择一个非整数变量，将其取值范围分为 “小于等于整数部分” 和 “大于等于整数部分 + 1” 两个分支，形成两个子问题；
- 3、对每个子问题重复上述过程（分支），并通过 “定界”（记录当前最优整数解，剪去不可能更优的分支）缩小搜索范围，直至找到最优解。
分支定界法适用于混合整数规划问题（MIP），本质上是一种 “智能枚举”，避免盲目枚举所有可能的整数组合，而是通过定界剪枝提高效率。python代码如下：
```python
import numpy as np
from scipy.optimize import linprog

class BranchAndBound:
    def __init__(self, c, A_ub, b_ub, A_eq, b_eq, bounds, integer_vars):
        """
        :param c: 目标函数系数向量
        :param A_ub: 不等式约束矩阵
        :param b_ub: 不等式约束向量
        :param A_eq: 等式约束矩阵
        :param b_eq: 等式约束向量
        :param bounds: 变量边界列表 [(min, max), ...]
        :param integer_vars: 整数变量索引列表
        """
        self.c = c
        self.A_ub = A_ub
        self.b_ub = b_ub
        self.A_eq = A_eq
        self.b_eq = b_eq
        self.bounds = bounds
        self.integer_vars = integer_vars
        self.best_solution = None
        self.best_value = float('inf')
        
    def solve(self):
        self._branch_and_bound([])
        return self.best_solution, self.best_value
    
    def _branch_and_bound(self, constraints):
        # 求解当前节点的线性松弛问题
        res = linprog(
            c=self.c,
            A_ub=self.A_ub,
            b_ub=self.b_ub,
            A_eq=self.A_eq,
            b_eq=self.b_eq,
            bounds=self.bounds,
            method='highs'
        )
        
        # 节点不可行或目标值已劣于当前最优解
        if not res.success or res.fun >= self.best_value:
            return
        
        x = res.x
        solution_found = True
        
        # 检查整数约束是否满足
        for i in self.integer_vars:
            if not np.isclose(x[i], round(x[i]), atol=1e-5):
                solution_found = False
                break
        
        # 找到更优整数解
        if solution_found and res.fun < self.best_value:
            self.best_solution = x
            self.best_value = res.fun
            return
        
        # 选择分支变量
        branch_var = None
        for i in self.integer_vars:
            if not np.isclose(x[i], round(x[i]), atol=1e-5):
                branch_var = i
                break
        
        if branch_var is None:
            return
        
        # 分支过程
        floor_val = np.floor(x[branch_var])
        ceil_val = np.ceil(x[branch_var])
        
        # 左分支 (x <= floor_val)
        new_bounds = self.bounds.copy()
        new_bounds[branch_var] = (self.bounds[branch_var][0], floor_val)
        self._branch_and_bound(constraints + [(branch_var, '<=', floor_val)])
        
        # 右分支 (x >= ceil_val)
        new_bounds = self.bounds.copy()
        new_bounds[branch_var] = (ceil_val, self.bounds[branch_var][1])
        self._branch_and_bound(constraints + [(branch_var, '>=', ceil_val)])

# ====================== 使用示例 ======================
if __name__ == "__main__":
    # 示例问题: 
    # max z = 5x1 + 8x2
    # s.t. x1 + x2 <= 6
    #      5x1 + 9x2 <= 45
    #      x1, x2 >= 0 且为整数
    
    # 转换为最小化问题: min -z = -5x1 -8x2
    c = [-5, -8]         # 目标函数系数
    A_ub = [[1, 1],      # 不等式约束矩阵
            [5, 9]]
    b_ub = [6, 45]       # 不等式约束向量
    bounds = [(0, None), (0, None)]  # 变量边界
    integer_vars = [0, 1]            # 整数变量索引
    
    # 求解问题
    bb = BranchAndBound(c, A_ub, b_ub, None, None, bounds, integer_vars)
    solution, value = bb.solve()
    
    # 输出结果 (注意目标值已转换回最大化问题)
    if solution is not None:
        print("最优解:", np.round(solution, 3))
        print("最优值 (最大化):", -value)  # 转换回最大化问题
    else:
        print("未找到可行解")
```

### （2）隐枚举法（Implicit Enumeration）
专为 0-1 规划设计，通过优先枚举目标函数较优的变量组合，并利用约束条件排除明显不可行的解（无需枚举所有可能），提高效率，python代码如下：
```python
import numpy as np

class ImplicitEnumeration:
    def __init__(self, c, A_ub, b_ub, A_eq, b_eq):
        """
        :param c: 目标函数系数向量
        :param A_ub: 不等式约束矩阵
        :param b_ub: 不等式约束向量
        :param A_eq: 等式约束矩阵
        :param b_eq: 等式约束向量
        """
        self.c = np.array(c)
        self.A_ub = np.array(A_ub) if A_ub is not None else None
        self.b_ub = np.array(b_ub) if b_ub is not None else None
        self.A_eq = np.array(A_eq) if A_eq is not None else None
        self.b_eq = np.array(b_eq) if b_eq is not None else None
        self.n = len(c)
        self.best_solution = None
        self.best_value = float('inf')
        
    def solve(self):
        self._enumerate([], 0)
        return self.best_solution, self.best_value
    
    def _enumerate(self, partial_sol, depth):
        # 到达叶子节点
        if depth == self.n:
            x = np.array(partial_sol)
            # 检查约束是否满足
            if self._check_constraints(x):
                obj_val = np.dot(self.c, x)
                # 更新最优解
                if obj_val < self.best_value:
                    self.best_solution = x.copy()
                    self.best_value = obj_val
            return
        
        # 剪枝: 检查当前部分解是否可能优化
        if self._bound(partial_sol, depth) >= self.best_value:
            return
        
        # 分支过程 (0-1枚举)
        for val in [0, 1]:
            new_sol = partial_sol + [val]
            self._enumerate(new_sol, depth + 1)
    
    def _check_constraints(self, x):
        # 检查不等式约束
        if self.A_ub is not None:
            if not np.all(self.A_ub @ x <= self.b_ub + 1e-5):
                return False
        # 检查等式约束
        if self.A_eq is not None:
            if not np.allclose(self.A_eq @ x, self.b_eq, atol=1e-5):
                return False
        return True
    
    def _bound(self, partial_sol, depth):
        """计算当前部分解的下界 (最小化问题)"""
        # 固定部分解的目标值
        fixed_obj = np.dot(self.c[:len(partial_sol)], partial_sol)
        
        # 自由变量的最优下界 (取可能的最小值)
        free_min = 0
        for i in range(depth, self.n):
            if self.c[i] < 0:  # 负系数取1可减少目标值
                free_min += self.c[i]
        return fixed_obj + free_min

# ====================== 使用示例 ======================
if __name__ == "__main__":
    # 示例问题: 
    # min z = 3x1 + 2x2 - 5x3
    # s.t. x1 + 2x2 + x3 <= 3
    #      x1 + 4x2 + 2x3 >= 5
    #      x1, x2, x3 ∈ {0,1}
    
    c = [3, 2, -5]           # 目标函数系数
    A_ub = [[1, 2, 1]]       # 不等式约束矩阵 (<=)
    b_ub = [3]               # 不等式约束向量
    A_eq = [[1, 4, 2]]       # 等式约束矩阵 (>= 需转换)
    b_eq = [5]               # 等式约束向量
    
    # 注意: 将>=约束转换为<=形式: -x1 -4x2 -2x3 <= -5
    A_ub = [[1, 2, 1], [-1, -4, -2]]
    b_ub = [3, -5]
    
    # 求解问题
    ie = ImplicitEnumeration(c, A_ub, b_ub, None, None)
    solution, value = ie.solve()
    
    if solution is not None:
        print("最优解:", solution)
        print("最优值:", value)
    else:
        print("未找到可行解")
```

## 2. 启发式算法（适用于大规模问题）
当问题规模较大（如变量数超过 1000），精确算法耗时过长，可采用近似算法求较优解，这些算法我们后面再详细学习，以下仅列举常见启发式算法：
- 遗传算法：模拟生物进化过程，通过 “选择、交叉、变异” 操作迭代搜索最优解。
- 模拟退火算法：模拟物理退火过程，允许一定概率接受较差解，避免陷入局部最优。
- 禁忌搜索：通过记录 “禁忌” 解（近期搜索过的解），避免重复搜索，扩大搜索范围。
